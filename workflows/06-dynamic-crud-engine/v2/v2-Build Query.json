{
  "name": "v2/Build Query",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Usar $input en subworkflows\nconst input = $input.first().json;\n\n// Desestructuración defensiva\nconst config = input.model_config || {};\nconst bodyRaw = input.body || {};\n// Detectar si el body es un array (para bulk) o un objeto con metadatos\nconst isBulk = Array.isArray(bodyRaw) || (bodyRaw.data && Array.isArray(bodyRaw.data));\nconst dataPayload = isBulk ? (Array.isArray(bodyRaw) ? bodyRaw : bodyRaw.data) : bodyRaw;\n// Si no es bulk, extraemos metadatos estándar (limit, offset vienen en body 'padre' si existen)\nconst meta = isBulk ? bodyRaw : dataPayload; \n\nconst operation = (input.operation || meta.operation || 'getall').toLowerCase();\nconst table = config.table_name;\n\nif (!table) throw new Error(`Modelo sin table_name configurado`);\n\n// --- CONFIGURACIÓN DE JOINS ---\nconst joins = config.joins || [];\nconst buildJoins = () => {\n    if (!joins.length) return '';\n    return joins.map(j => \n        ` LEFT JOIN ${j.table} ON ${table}.${j.own_col} = ${j.table}.${j.foreign_col}`\n    ).join(' ');\n};\n\n// Generador de SELECT inteligente\nconst buildSelectFields = () => {\n    if (!joins.length) return `${table}.*`;\n    let select = `${table}.*`;\n    joins.forEach(j => {\n        select += `, row_to_json(${j.table}.*) as ${j.table}_data`;\n    });\n    return select;\n};\n\nlet query = '';\nlet values = [];\n\n// --- LÓGICA CORE ---\n\nswitch (operation) {\n  case 'insert': {\n    // SOPORTE BULK INSERT\n    if (isBulk && dataPayload.length > 0) {\n        const cols = Object.keys(dataPayload[0]);\n        // Validar consistencia de columnas (opcional, asumo estructura homogénea por performance)\n        \n        let paramIndex = 1;\n        const rowPlaceholders = [];\n        values = [];\n\n        dataPayload.forEach(row => {\n            const rowParams = [];\n            cols.forEach(col => {\n                rowParams.push(`$${paramIndex++}`);\n                values.push(row[col]);\n            });\n            rowPlaceholders.push(`(${rowParams.join(', ')})`);\n        });\n\n        // Transacción implícita en un solo statement, pero envolvemos si se pide explícitamente\n        query = `INSERT INTO ${table} (${cols.join(', ')}) VALUES ${rowPlaceholders.join(', ')} RETURNING *;`;\n        \n    } else {\n        // INSERT SIMPLE\n        const fields = dataPayload.fields || dataPayload; // Soporte para estructura {fields: {}} o directo\n        const cols = Object.keys(fields);\n        query = `INSERT INTO ${table} (${cols.join(', ')}) VALUES (${cols.map((_, i) => `$${i + 1}`).join(', ')}) RETURNING *;`;\n        values = Object.values(fields);\n    }\n    break;\n  }\n\n  case 'bulkinsert': {\n      // Alias explícito por si llega como operación nombrada\n      // ... (misma lógica que arriba, puedes refactorizar a función)\n      // Por brevedad, asume que cae en el 'if (isBulk)' del case insert si se normaliza la entrada.\n      break;\n  }\n\n  case 'update': {\n    const fields = dataPayload.fields || {};\n    const pkField = config.primary_key || 'id';\n    const pkValue = fields[pkField] || meta.id || meta.filter_value;\n    \n    // Eliminamos PK del set de actualización\n    const updateFields = { ...fields };\n    delete updateFields[pkField];\n\n    const cols = Object.keys(updateFields);\n    if (cols.length === 0) throw new Error('No hay campos para actualizar');\n    \n    const setClause = cols.map((c, i) => `${c} = $${i + 1}`).join(', ');\n    values = Object.values(updateFields);\n    values.push(pkValue); \n\n    query = `UPDATE ${table} SET ${setClause} WHERE ${pkField} = $${values.length} RETURNING *;`;\n    break;\n  }\n\n  case 'delete': {\n    const pkField = config.primary_key || 'id';\n    const pkValue = dataPayload[pkField] || meta.id || meta.filter_value;\n    if (!pkValue) throw new Error(`Falta el valor de ${pkField} para eliminar`);\n    query = `DELETE FROM ${table} WHERE ${pkField} = $1 RETURNING *;`;\n    values = [pkValue];\n    break;\n  }\n    \n  case 'getone': {\n    const pkField = config.primary_key || 'id';\n    const val = meta[pkField] || meta.filter_value || meta.id;\n    if (!val) throw new Error(`Falta identificador para getOne`);\n    \n    query = `SELECT ${buildSelectFields()} FROM ${table} ${buildJoins()} WHERE ${table}.${pkField} = $1;`;\n    values = [val];\n    break;\n  }\n\n  case 'getall': {\n    const select = buildSelectFields();\n    const joinSql = buildJoins();\n    \n    // PAGINACIÓN ROBUSTA\n    // Usamos parámetros para limit/offset para evitar inyección SQL\n    const limit = meta.limit ? parseInt(meta.limit) : 100;\n    const offset = meta.offset ? parseInt(meta.offset) : 0;\n    \n    // Construcción base\n    let baseQuery = `SELECT ${select} FROM ${table} ${joinSql}`;\n    \n    // Filtros dinámicos simples (si vienen en fields)\n    const allowedFields = config.allowed_fields || [];\n    const filterFields = Object.fromEntries(\n      Object.entries(meta.fields || {})\n        .filter(([key]) => allowedFields.includes(key))\n    );\n\n    const filterKeys = Object.keys(filterFields);\n    if (filterKeys.length > 0) {\n        const whereClause = filterKeys.map((k, i) => `${table}.${k} = $${i + 1}`).join(' AND ');\n        baseQuery += ` WHERE ${whereClause}`;\n        values = Object.values(filterFields);\n    }\n\n    // Append Pagination\n    // Nota: Postgres permite LIMIT $n OFFSET $m\n    const paramStart = values.length + 1;\n    query = `${baseQuery} LIMIT $${paramStart} OFFSET $${paramStart + 1};`;\n    values.push(limit, offset);\n    break;\n  }\n\n  default:\n    return [{\n      json: {\n        error: true,\n        status: 400,\n        message: `Operación no soportada: ${operation}`,\n        code: \"SCHEMA_VALIDATION\"\n      }\n    }];\n}\n\n// --- TRANSACCIONES ---\n// Si la operación es masiva o crítica, envolvemos.\n// Nota: n8n Postgres node ejecuta todo el string.\nreturn [{\n  json: {\n    query,\n    values,\n    operation,\n    transactional: isBulk || operation === 'delete'\n  }\n}];\n\n\n/*\nif (isBulk || config.use_transaction || operation === 'delete') {\n    query = `BEGIN; ${query} COMMIT;`;\n}\n\nreturn [{\n  json: {\n    query,\n    values,\n    operation\n  }\n}];\n*/"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        -176
      ],
      "id": "c6ff55ec-01ed-486c-8e32-0f0c2cc1c5f5",
      "name": "Build Query"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        32,
        -176
      ],
      "id": "f94cd53a-539a-452f-a5e5-b1eb5ed81bff",
      "name": "When Executed by Another Workflow"
    }
  ],
  "pinData": {},
  "connections": {
    "Build Query": {
      "main": [
        []
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Build Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "9SrVXdATmlrZemJT"
  },
  "versionId": "b2b956e9-0754-4256-ace3-7335d380d4e2",
  "meta": {
    "instanceId": "2ebfe6551ca260f617d68572b7a0eb6825fe3993d0da19ebfb0e274f2e0ccb37"
  },
  "id": "NO6LIndnkfNuxK5N",
  "tags": []
}