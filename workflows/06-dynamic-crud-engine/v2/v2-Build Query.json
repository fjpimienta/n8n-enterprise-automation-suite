{
  "name": "v2/Build Query",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// 1. Captura de entrada\nconst input = $input.first().json;\nconst config = input.model_config || {};\n\n// 2. Prioridad de Operación\nlet operation = (input.operation || (input.body && input.body.operation) || 'getall').toLowerCase().trim();\n\n// 3. Extraer los datos\nconst body = input.body || {};\nconst fields = body.fields || body; // Acepta tanto {fields: {...}} como el objeto directo\n\nconst table = config.table_name;\nif (!table) throw new Error(`Modelo sin table_name configurado. Recibido: ${JSON.stringify(input)}`);\n\nconst joins = config.joins || [];\nconst buildJoins = () => {\n    if (!joins.length) return '';\n    return joins.map(j => ` LEFT JOIN ${j.table} ON ${table}.${j.own_col} = ${j.table}.${j.foreign_col}`).join(' ');\n};\n\nconst buildSelectFields = () => {\n    if (!joins.length) return `${table}.*`;\n    let select = `${table}.*`;\n    joins.forEach(j => { select += `, row_to_json(${j.table}.*) as ${j.table}_data`; });\n    return select;\n};\n\nlet query = '';\nlet values = [];\n\nswitch (operation) {\n    case 'insert': {\n        const allowedFields = config.allowed_fields || [];\n        const insertFields = [];\n        const placeholders = [];\n        let paramIndex = 1;\n\n        Object.entries(fields).forEach(([key, value]) => {\n            if (allowedFields.includes(key)) {\n                insertFields.push(key);\n                placeholders.push(`$${paramIndex++}`);\n                values.push(value);\n            }\n        });\n\n        if (insertFields.length === 0) throw new Error(\"No hay campos válidos para insertar.\");\n        \n        // Construimos la actualización dinámica para el conflicto\n        const updateStr = insertFields\n            .filter(f => f !== 'url' && f !== 'id' && f !== 'created_at')\n            .map(f => `${f} = EXCLUDED.${f}`)\n            .join(', ');\n\n        query = `\n            INSERT INTO ${table} (${insertFields.join(', ')}) \n            VALUES (${placeholders.join(', ')}) \n            ON CONFLICT (${config.primary_key}) \n            DO UPDATE SET ${updateStr}\n            RETURNING *;\n        `;\n        break;\n    }\n\n    case 'getall': {\n        const limit = body.limit || 100;\n        const offset = body.offset || 0;\n        const allowedFields = config.allowed_fields || [];\n        \n        let baseQuery = `SELECT ${buildSelectFields()} FROM ${table} ${buildJoins()}`;\n        let whereParts = [];\n        let paramIndex = 1;\n\n        Object.entries(fields).forEach(([key, value]) => {\n            if (allowedFields.includes(key)) {\n                // CAMBIO: Soporte para NULL (IS NULL / IS NOT NULL)\n                if (value === null) {\n                    whereParts.push(`${table}.${key} IS NULL`);\n                } \n                else if (value !== null && typeof value === 'object' && !Array.isArray(value)) {\n                    Object.entries(value).forEach(([op, val]) => {\n                        const sqlOp = op === '_gte' ? '>=' : op === '_lte' ? '<=' : op === '_gt' ? '>' : op === '_lt' ? '<' : '=';\n                        whereParts.push(`${table}.${key} ${sqlOp} $${paramIndex++}`);\n                        values.push(val);\n                    });\n                } else {\n                    whereParts.push(`${table}.${key} = $${paramIndex++}`);\n                    values.push(value);\n                }\n            }\n        });\n\n        if (whereParts.length > 0) baseQuery += ` WHERE ${whereParts.join(' AND ')}`;\n        baseQuery += ` ORDER BY ${table}.created_at DESC`;\n        query = `${baseQuery} LIMIT $${paramIndex++} OFFSET $${paramIndex++};`;\n        values.push(limit, offset);\n        break;\n    }\n\n    case 'getone': {\n        const pkField = config.primary_key || 'id';\n        let searchField = pkField;\n        let val = fields[pkField] || body[pkField] || body.id;\n\n        if (!val && Object.keys(fields).length > 0) {\n            searchField = Object.keys(fields)[0];\n            val = fields[searchField];\n        }\n        \n        if (!val) throw new Error(`Operación GETONE requiere un ID.`);\n        query = `SELECT ${buildSelectFields()} FROM ${table} ${buildJoins()} WHERE ${table}.${searchField} = $1 LIMIT 1;`;\n        values = [val];\n        break;\n    }\n\n    default:\n        query = `SELECT * FROM ${table} LIMIT 10;`;\n}\n\nreturn [{\n    json: { query, values, operation, is_transactional: ['insert', 'update', 'delete'].includes(operation) }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        -176
      ],
      "id": "c6ff55ec-01ed-486c-8e32-0f0c2cc1c5f5",
      "name": "Build Query"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        32,
        -176
      ],
      "id": "f94cd53a-539a-452f-a5e5-b1eb5ed81bff",
      "name": "When Executed by Another Workflow"
    }
  ],
  "pinData": {},
  "connections": {
    "Build Query": {
      "main": [
        []
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Build Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "9SrVXdATmlrZemJT"
  },
  "versionId": "9adc4e7b-7b2d-4961-9f61-834a702c6654",
  "meta": {
    "instanceId": "75957d34f9f0189415b8c82ca3ce42d8f0b464efd869382da2158435b39f044d"
  },
  "id": "NO6LIndnkfNuxK5N",
  "tags": []
}