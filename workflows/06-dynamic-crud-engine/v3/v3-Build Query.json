{
  "name": "v3/Build Query",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// 1. Importar librería de criptografía nativa de Node.js\nconst crypto = require('crypto');\n\n// 2. Captura de entrada\nconst input = $input.first().json;\n\n// 3. Validar si existe la configuración necesaria\nif (!input.model_config || !input.model_config.table_name) {\n    return [{ json: input }];\n}\n\nconst config = input.model_config;\n\n// 4. Prioridad de Operación\nlet operation = (input.operation || (input.body && input.body.operation) || 'getall').toLowerCase().trim();\n\n// 5. Extraer los datos\nconst body = input.body || {};\nconst fields = body.filters || body.fields || body;\n\nconst table = config.table_name;\nif (!table) throw new Error(`Modelo sin table_name configurado. Recibido: ${JSON.stringify(input)}`);\n\nconst joins = config.joins || [];\nconst buildJoins = () => {\n    if (!joins.length) return '';\n    return joins.map(j => ` LEFT JOIN ${j.table} ON ${table}.${j.own_col} = ${j.table}.${j.foreign_col}`).join(' ');\n};\n\nconst buildSelectFields = () => {\n    if (!joins.length) return `${table}.*`;\n    let select = `${table}.*`;\n    joins.forEach(j => { select += `, row_to_json(${j.table}.*) as ${j.table}_data`; });\n    return select;\n};\n\n// --- FUNCIÓN HELPER PARA ENCRIPTAR ---\nconst processValue = (key, value) => {\n    if (key === 'password' && value) {\n        return crypto.createHash('sha256').update(value).digest('hex');\n    }\n    return value;\n};\n// -------------------------------------\n\nlet query = '';\nlet values = [];\n\nswitch (operation) {\n    case 'insert': {\n        const allowedFields = config.allowed_fields || [];\n        const insertFields = [];\n        const placeholders = [];\n        let paramIndex = 1;\n\n        Object.entries(fields).forEach(([key, value]) => {\n            if (allowedFields.includes(key)) {\n                insertFields.push(key);\n                placeholders.push(`$${paramIndex++}`);\n                values.push(processValue(key, value));\n            }\n        });\n\n        if (insertFields.length === 0) throw new Error(\"No hay campos válidos para insertar.\");\n        \n        // --- LÓGICA DE CLAVE PARA CONFLICTO ---\n        \n        // 1. Empezamos con la PK definida en el crud_models (ej: 'id' o 'email')\n        let effectivePk = config.primary_key;\n        \n        // 2. Si la PK es 'id' pero NO estamos enviando un valor para 'id' (porque es autoincremental)\n        //    buscamos un \"candidato a llave única\" en los campos que sí enviamos.\n        if (effectivePk === 'id' && !fields.id) {\n            if (fields.doc_id) {\n                effectivePk = 'doc_id'; // Si viene doc_id, es mejor candidato que el email\n            } else if (fields.email) {\n                effectivePk = 'email'; // Respaldo tradicional\n            }\n        }\n\n        const updateStr = insertFields\n            .filter(f => f !== 'url' && f !== 'id' && f !== 'created_at' && f !== effectivePk)\n            .map(f => `${f} = EXCLUDED.${f}`)\n            .join(', ');\n\n        query = `\n            INSERT INTO ${table} (${insertFields.join(', ')}) \n            VALUES (${placeholders.join(', ')}) \n            ON CONFLICT (${effectivePk}) \n            DO UPDATE SET ${updateStr}\n            RETURNING *;\n        `;\n        break;\n    }\n\n    case 'update': {\n        const allowedFields = config.allowed_fields || [];\n        const pkFieldFromConfig = config.primary_key || 'id';\n        \n        // CORRECCIÓN: Si el body no tiene la PK definida en config, buscamos por email\n        const idValue = body[pkFieldFromConfig] || fields[pkFieldFromConfig] || body.id || fields.id || body.email || fields.email;\n        \n        // Si el valor que encontramos es un email y la config decía 'id', asumimos que la PK real es email\n        const pkField = (pkFieldFromConfig === 'id' && !fields.id && idValue && typeof idValue === 'string' && idValue.includes('@')) ? 'email' : pkFieldFromConfig;\n\n        if (!idValue) throw new Error(`Operación UPDATE requiere un ID o el campo de llave primaria (${pkField}).`);\n\n        const updateParts = [];\n        let paramIndex = 1;\n        \n        Object.entries(fields).forEach(([key, value]) => {\n            if (allowedFields.includes(key) && key !== 'id' && key !== pkField) {\n                \n                // --- PROTECCIÓN DE PASSWORD ---\n                // Si el campo es password y viene null, undefined o vacío, NO lo agregamos al query\n                if (key === 'password' && (value === null || value === undefined || value === '')) {\n                    return; \n                }\n\n                updateParts.push(`${key} = $${paramIndex++}`);\n                values.push(processValue(key, value));\n            }\n        });\n        \n        if (updateParts.length === 0) throw new Error(\"No hay campos válidos para actualizar.\");\n        \n        query = `UPDATE ${table} SET ${updateParts.join(', ')} WHERE ${pkField} = $${paramIndex++} RETURNING *;`;\n        values.push(idValue);\n        break;\n    }\n\n    case 'getall': {\n        const limit = body.limit || 100;\n        const offset = body.offset || 0;\n        const allowedFields = config.allowed_fields || [];\n        \n        let baseQuery = `SELECT ${buildSelectFields()} FROM ${table} ${buildJoins()}`;\n        let whereParts = [];\n        let paramIndex = 1;\n\n        Object.entries(fields).forEach(([key, value]) => {\n            if (allowedFields.includes(key) && key !== 'limit' && key !== 'offset') {\n                if (value === null) {\n                    whereParts.push(`${table}.${key} IS NULL`);\n                } else if (typeof value === 'object' && !Array.isArray(value)) {\n                    Object.entries(value).forEach(([op, val]) => {\n                        const sqlOp = op === '_gte' ? '>=' : op === '_lte' ? '<=' : op === '_gt' ? '>' : op === '_lt' ? '<' : '=';\n                        const isDate = typeof val === 'string' && val.includes('T') && val.length > 10;\n                        \n                        if (isDate) {\n                            whereParts.push(`${table}.${key}::date ${sqlOp} $${paramIndex++}::date`);\n                            values.push(val.split('T')[0]);\n                        } else {\n                            whereParts.push(`${table}.${key} ${sqlOp} $${paramIndex++}`);\n                            values.push(val);\n                        }\n                    });\n                } else if (value !== undefined && value !== '') {\n                    whereParts.push(`${table}.${key} = $${paramIndex++}`);\n                    values.push(value);\n                }\n            }\n        });\n\n        // 2. Default Filter (IMPORTANTE: Solo añadir si no se está filtrando manualmente is_active)\n        if (config.default_filter && !fields.hasOwnProperty('is_active')) {\n            // Si el filtro de la DB tiene un $1 (ej: id_company=$1), lo ignoramos en GETALL \n            // a menos que sea una condición fija como 'is_active = true'\n            if (!config.default_filter.includes('$1')) {\n                whereParts.push(config.default_filter);\n            }\n        }\n\n        if (whereParts.length > 0) baseQuery += ` WHERE ${whereParts.join(' AND ')}`;\n        \n        // 3. Paginación (Los parámetros finales siempre son limit y offset)\n        baseQuery += ` ORDER BY ${table}.created_at DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++};`;\n        \n        query = baseQuery;\n        values.push(limit, offset);\n        break;\n    }\n    \n    case 'delete': {\n        const pkField = config.primary_key || 'id';\n        const idValue = body[pkField] || fields[pkField] || body.id || fields.id;\n        \n        if (!idValue) throw new Error(`DELETE requiere el valor de ${pkField}`);\n\n        // Si la tabla es de logs o noticias, podrías querer un DELETE físico, \n        // pero siguiendo tu lógica de \"borrado lógico\":\n        query = `UPDATE ${table} SET is_active = false WHERE ${pkField} = $1 RETURNING *;`;\n        values = [idValue];\n        break;\n    }\n    \n    case 'getone': {\n        const pkField = config.primary_key || 'id';\n        let val = fields[pkField] || body[pkField] || body.id || fields.id || fields.email || body.email;\n\n        if (!val && Object.keys(fields).length > 0) {\n            const firstKey = Object.keys(fields)[0];\n            val = fields[firstKey];\n            query = `SELECT ${buildSelectFields()} FROM ${table} ${buildJoins()} WHERE ${table}.${firstKey} = $1 LIMIT 1;`;\n        } else if (val) {\n            const searchField = (fields.email || body.email) && !fields[pkField] ? 'email' : pkField;\n            query = `SELECT ${buildSelectFields()} FROM ${table} ${buildJoins()} WHERE ${table}.${searchField} = $1 LIMIT 1;`;\n        }\n        \n        if (!val) throw new Error(`Operación GETONE requiere un ID o un campo de búsqueda.`);\n        values = [val];\n        break;\n    }\n\n    default:\n        query = `SELECT * FROM ${table} LIMIT 10;`;\n}\n\nreturn [{\n    json: { query, values, operation, is_transactional: ['insert', 'update', 'delete'].includes(operation) }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        -176
      ],
      "id": "3fe5b789-b5a3-4da3-b940-de5fb100fedb",
      "name": "Build Query"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        32,
        -176
      ],
      "id": "e6782894-4f2a-41e7-9ca0-b25d4c0f7500",
      "name": "When Executed by Another Workflow"
    }
  ],
  "pinData": {},
  "connections": {
    "Build Query": {
      "main": [
        []
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Build Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "9SrVXdATmlrZemJT"
  },
  "versionId": "f9dcd14d-dd82-441e-87c3-93e5f3db075d",
  "meta": {
    "instanceId": "75957d34f9f0189415b8c82ca3ce42d8f0b464efd869382da2158435b39f044d"
  },
  "id": "8a8OzpBuLa1C9wqk",
  "tags": []
}